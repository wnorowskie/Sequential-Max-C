Eric Wnorowski
Professor Smith
CS-377: Parallel Programming
9 September 2022
                                    Assignment One: Sequential Max in C
    After a summer of coding in python I had to open the C textbook to re-familiarize myself with the syntax of the language. For starters I just laid out some pseudocode for the sequential max function, determining what my helper functions would be. I understood that we had to make three separate versions of it, but first I wanted to have the core functionality written out before trying to mess with the different variations. I just wanted to try and write out the program the way I thought was correct. Then decided tp go back and check to conform to the different version standards. It took my a few different textbook and google searches to insert the correct syntax for C. I referenced the chapters within our given textbook by Kernighan and Ritchie through the assignment to ensure that I was formatting and coding properly. After completing my first version on my own, I went back to the assignment instructions. aI did it in the same version as the first version instructed. I am used to coding in Java and Python so the typical array notation is standard for me. I utilized scanf() and printf() as well as some of the other suggested functions. Finding the sequential max is a relatively simple problem because we are simply creating an array of n numbers and then sorting through that list one by one to find the maximum value. The only variation that comes with C is the manner in which an array is created and then accessed. 
	When I originally created my first version I created a maximum of 1000 spaces for the array, and included a request to the user for the length of the array. I was still inquiring for the length of the array originally because the assignment description had said to ask the user for the length of the array. So I would assign the length of the array as long as it was under one hundred, but not dynamically allocating via malloc() or calloc(). But before I tried the second and third version I wanted to understand the difference between normal array indexing and array pointers. After some research in the C textbook as well as a youtube video or two I had a firm grasp on the concept and copied over the first version and tweaked it so that it would only use pointers. Finally I repeated these steps for the third version, first just taking some time to review malloc() and calloc() for dynamic allocation, and then introducing it into my program. This process of creating the different versions became simple when first I could understand how these basic functions worked within the C language. My original pseudocode ended up being fairly accurate to the final product, just had to recall the details of user input, arrays, looping, printing, sorting, etc.
	With that said I feel like this assignment was a nice warm-up to allow us to recall the C language and work through the vim editor as well as compiling and executing via unix command prompt. It was a simple enough algorithm but implemented many core functions and required us to understand the differences in the way our array was formulated. Ultimately my first version had nearly identical logic to my third version, but the change in memory allocation, when scaled would make a difference in the software. Which I believe has been the goal of these first few classes, to understand the complexities of concurrency and the role it has in software today.

